进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。
一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。
进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。
解压文件是CPU密集型任务，在单核CPU上，单线程的性能要比多线程高

实现多线程最基本的两种方式是：继承Thread类和实现Runnable接口，其中Thread类也实现了Runnable接口，所以基于Thread和Runnable创建多线程都需要实现run方法，run方法是多线程真正运行的主方法。

start()方法是Thread类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上执行，会放到等待队列中等待CPU调用，只有线程真正被CPU调度时才会调用run()方法执行。start()方法只是标识线程为就绪状态的一个附加方法，被标识为synchronized。
	
云：互联网的基础设施 
云计算:
	云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。

促进操作系统支持多程序同时执行的关注点：资源利用、公平、方便。
一个类是线程安全的，是指在被多个线程访问时，类可以持续进行正确的行为。
当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码不必作其他的协调，这个类的行为仍然是正确的，那么称这个类是线程安全的。

无状态对象永远是线程安全的。

竞争条件：
	当计算的正确性依赖于运行时中相关的时序或者多线程的交替时，会产生竞争条件；换句话说，想得到正确的答案，要依赖于“幸运”的时序。
	最常见的一种竞争条件是“检查再运行”，使用一个潜在的过期值作为决定下一步操作的依据。
	检查再运行的常见用法是惰性初始化。惰性初始化的目的是延迟对象的初始化，直到程序真正使用它，同时确保它只初始化一次。
数据竞争：
	出现于没有使用同步来协调所有那些共享的非final域访问的情况。一个线程写入一个变量，可以被另一个线程读取；一个线程读取刚刚被另一个线程写入的变量，如果两个线程都没有使用同步，你将会处于数据竞争的风险中。处于数据竞争下的代码，在Java存储模型中并没有明确定义的语义。不是所有竞争条件都是数据竞争，同样不是所有的数据竞争都是竞争条件，不过它们都会引起并发程序以不可预期的方式失败。

内部锁：
	内部锁在Java中扮演了互斥锁的角色，意味着至多只有一个线程可以拥有锁，当线程A尝试请求一个被线程B占有的锁时，线程A必须等待或者阻塞，直到B释放它。如果B永远不释放锁，A将永远等下去。
重进入：
	当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞。然而内部锁是可重进入的，因此线程在试图获得它自己占有的锁时，请求会成功。重进入意味着锁的请求是基于“每线程”，而不是基于“每调用”的。重进入的实现是通过为每个锁关联一个请求计数和一个占有它的线程。当计数为0时，认为锁是未被占有的。线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数置为1。如果同一线程再次请求这个锁，计数将递增；每次占用线程退出同步快，计数器值将递减。直到计数器达到0时，锁被释放。
对象的串行访问与对象的序列化毫无关系；不间断访问意味着线程依次独占地访问对象，而不是并发访问。

加锁可以保证可见性与原子性；volatile变量只能保证可见性。
满足使用volatile变量的条件：
	写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值；
	变量不需要与其他状态变量共同参与不变约束；
	而且，访问变量时，没有其他的原因需要加锁。

ThreadLocal：
	ThreadLocal变量通常用于防止在基于可变的单体或全局变量的设计中，出现（不正确）共享。

不可变对象永远是线程安全的。
只有满足如下状态，一个对象才是不可变的：
	它的状态不能在创建后再被修改；
	所有域都是final类型，并且，
	它被正确创建（创建期间没有发生this引用的逸出）

为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过下列条件安全地发布：
	通过静态初始化器初始化对象的引用；
	将它的引用存储到volatile域或AtomicReference；
	将它的引用存储到正确创建的对象的final域中；
	或者将它的引用存储到由锁正确保护的域中。